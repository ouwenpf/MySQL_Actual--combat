# 常用备份工具

[名词解释](https://blog.csdn.net/joe_007/article/details/7014381)  
[参考资料](https://www.jianshu.com/p/4e3edbedb9a8)

## mysqldump工具
mysqldump --single-transaction --master-data=2   
一定需要加上以上2个参数，但是不支持非事务表，如果不加入此参数备份是数据不一致性的备份或者是无效的备份
```
mysqldump --single-transaction --master-data=2 
-A：备份所有库
-B：备份单个库(生成create database语句)，-B database_name1 database_name2 ..
-d：只导出表结构  mysqldump -d  --triggers-false
-t：只导出数据  mysqldump  --single-transaction --triggers-false -t
-n: 如果使用了-B参数，在备份文件中不为每个库添加create database 语句
--where="1=1 limit 10000"：导出前10000行数据
-x：备份非事务表，锁定所有的表进行备份，对业务有影响，但是为了数据一致性必须这样做
-R:表示导出function和procedure和触发器,常用-ntd -R -E(--triggers=false)默认导出触发器  mysqldump  -Rntd  --triggers-false
-E:表示只导出事件  mysqldump  -Entd  --triggers-false
--triggers:只导出触发器 mysqldump  -ntd  --triggers
mysqldump最佳实践：
mysqldump --single-transaction --master-data=2  --set-gtid-purged=off -A |gzip > $dbname-$port-`date +%Y%m%d`.sql.gz
gzip：也可以换成bzip2或xz更高效的压缩比工具
zact test.sql.gz|mysql -p123456 test

以上备份作为主从关系数据一致性得到保障，如果不是这样的关系备份需要加上以下参数
--set-gtid-purged=off然后再导入数据
https://juejin.cn/post/7056604185042616350#heading-3

备份库：
mysqldump -S /tmp/mysql3306.sock --single-transaction --master-data=2 --set-gtid-purged=OFF -B `mysql -S  /tmp/mysql3306.sock  -e 'show databases;'|egrep -v 'information_schema|performance_schema|mysql|sys'|sed '1d'` |gzip >  fulldata_name-$port-`date +%Y%m%d`.sql.gz
备份数据库+存储过程函数-触发器
mysqldump -S /tmp/mysql3306.sock --single-transaction --master-data=2 --set-gtid-purged=OFF -R -B `mysql -S  /tmp/mysql3306.sock  -e 'show databases;'|egrep -v 'information_schema|performance_schema|mysql|sys'|sed '1d'` |gzip >  fulldata_name-$port-`date +%Y%m%d`.sql.gz
只备份存储过程函数-触发器
mysqldump -S /tmp/mysql3306.sock --single-transaction --master-data=2 --set-gtid-purged=OFF -ntd -R -B `mysql -S  /tmp/mysql3306.sock  -e 'show databases;'|egrep -v 'information_schema|performance_schema|mysql|sys'|sed '1d'` |gzip >  fulldata_name-$port-`date +%Y%m%d`.sql.gz

```

### mysqldump工具执行原理
流程如下：   
```
1. flush tables;  medata lock如果拿不到说明有长事务或者DDL
2. flush table with read lock; 关闭所有的表，并给所有数据库的表加上一个global read lock  
							   这个对于backup操作来说很有用，加锁之后
							  需要注意:如果ftwrl前面有运行的慢sql,由于慢sql阻塞了当前ftwrl,即使当前ftwrl退出了,后面也会有影响,直到慢sql执行完毕
3. set session transaction isolation level repeatable read;(可重复读)
4. start transaction;事务开始,起始点
5. get gtid;
6. show master status;
7. unlock tables;

8. savepoint sp(事务内的断点);
9. show tables;
	show create table tb_name1;
	select * from tb_name1;
10. rollback to savepoin sp;每次此操作是为了备份过程中释放备份过程中占用的内存，减少内存的开销
	show create table tb_name2;
	select * from tb_name2;
......
11. rollback to savepoin sp;
12. release savepoin sp;
注意8.0中引入了lock instance for backup (只是锁住MyISAM引擎,Frm,CSV文件)，不能操作DDL，写入数据是可以的，对于逻辑备份没有作用还是和5.7是一样的原理，对于物理备份xtrabackup是有作用，不要搞混了,只是更加轻量级相对于flush table with read lock.

所有备份在一个连接里面进行，单进程，所有mysqldump备份时间很长，效率不高

可以使用pathon或者其它语言编写多线程进行备份，思路如下：
master_thread
		flush tables;
		FTWRL
	 t1:set session transaction isolation level repeatable read;
	 	show master status;
		unlock tables;
	 t3:unlock tables;
	 
worker_thread
	 t2 c1:set session transaction isolation level repeatable read;
	 t2 c1:start transcation;
	 
	 t4: 
	 	savepoint sp;
		...
		rollback to savepoin sp;
	 
worker_thread
	 t2 c2:set session transaction isolation level repeatable read;
	 t2 c2:start transcation;

	 t4: 
	 	savepoint sp;
		...
		rollback to savepoin sp;
	 

	 
worker_thread
	 t2 c3:set session transaction isolation level repeatable read;
	 t2 c3:start transcation;
	 
	 t4: 
	 	savepoint sp;
		...
		rollback to savepoin sp;	 

worker_thread
	 t2 c4:set session transaction isolation level repeatable read;
	 t2 c4:start transcation;
	 
	 t4: 
	 	savepoint sp;
		...
		rollback to savepoin sp;
```

### xtrabackup备份及原理
[下载地址](https://www.percona.com/downloads/Percona-XtraBackup-2.4/LATEST/)   
[压缩备份](https://www.percona.com/doc/percona-xtrabackup/LATEST/innobackupex/streaming_backups_innobackupex.html)  
xtrabackup备份流程  
![](images/9-常用备份工具/常用备份工具1.jpg)  
![](images/9-常用备份工具/常用备份工具2.jpg)  
![](images/9-常用备份工具/备份过程3.jpg) 

###xtrabackup最小化授权
[参考资料](https://www.percona.com/doc/percona-xtrabackup/8.0/using_xtrabackup/privileges.html)  
正常授权只需要SELECT,RELOAD,LOCK TABLES,SUPER,BACKUP_ADMIN,PROCESS,REPLICATION (针对8.0)

```
5.7版本备份
备份：
	innobackupex  --defaults-file=/data/mysql/mysql3306/my.cnf -S /tmp/mysql3306.sock    --no-timestamp /data/backup   
 	
应用日志(crash-recovery)
	  innobackupex --apply-log /data/backup/2019-02-25_12-54-58/
	  --user-memory=1G
	  --user-memory = innodb_buffer_pool_size
还原：
	innobackupex   --defaults-file=/data/mysql/mysql3306/my.cnf --copy-back|--move-back  /data/backup/2019-02-25_12-54-58   
删除ib_logfile*文件 才可以拷贝
如果此命令拷贝不了，直接cp /data/backup/2019-02-25_12-54-58 /data/mysql/mysql3306/data/



8.0备份略有不同参数
备份：
/application/xtrabackup-8.0.30/bin/xtrabackup  --user=dba_backup --password=123456 --host=127.0.0.1  --port=3306  --parallel=8 --use-memory=2G   --target-dir=/data/backup/`date +%F\%H%M%S`  --backup 

/application/xtrabackup-8.0.30/bin/xtrabackup  --user=dba_backup --password=123456 --host=127.0.0.1  --port=3306  --parallel=8 --use-memory=2G   --target-dir=/data/backup/`date +%F\%H%M%S`  --backup 2>back.log

 
	
	
backup-lock-timeout 能够在存在备份锁等待的情况下 超过参数指定时间后，放弃备份任
务，优先保障实例上面SQL命令的执行。
kill-long-queries-timeout 能够在有Long-quer阻塞的情况下 杀掉长查询的sessio
n，优先保障备份任务的执行。


还原:
	xtrabackup   --target-dir=/data/backup8  --prepare
	xtrabackup    --defaults-file=/data/mysql/mysql3306/my.cnf    -ubackup -p123456    -S  /tmp/mysql3306.sock   --target-dir=/data/backup  --copy-back|--move-back 
	删除ib_logfile*文件 才可以拷贝
如果此命令拷贝不了，直接cp /data/backup/2019-02-25_12-54-58 /data/mysql/mysql3306/data/

xtrabackup8.0通过访问performance_schema.log_status来实现一致性的备份,摒弃了ftwrl重量级全局锁的弊端,如果有混合引擎采用lock instance for backup来实现一致性备份,相对也比较轻量级
所以在线上的环境不要随意访问performance_schema.log_status表,会导致性能下降(由于不能写入binlog在访问这个表)
```

加密备份:
openssl rand -base64 24
--encrypt=AES256 --encrypt-key=$KEY
--decrypt=AES256 --encrypt-key=$KEY

xtrabackup    --defaults-file=/data/mysql/mysql3306/my.cnf    -ubackup -p123456    -S  /tmp/mysql3306.sock --encrypt=AES256  --encrypt=AES256 --encrypt-key=$KEY   --target-dir=/tools/backup  --backup
xtrabackup   --target-dir=/data/backup  --decrypt=AES256 --encrypt-key=$KEY --prepare

+0yFVV+5fWeFjOj1rAcG3WAR5KGPGnj9
### 位置点信息不一致
xtrabackup_binlog_info：数据从show master status中读取  
xtrabackup_binlog_pos_innodb：数据从redo log last commit filename和postion中读出  

远程压缩备份:
xtrabackup    --defaults-file=/data/mysql/mysql3306/my.cnf    -ubackup -p123456    -S  /tmp/mysql3306.sock    --backup   --stream=xbstream  --target-dir=./ |ssh 10.0.8.11  "cat - >/tools/backup/db3306_`date +%Y%m%d`.xbstream"
多线程stream方式备份
xtrabackup    --defaults-file=/data/mysql/mysql3306/my.cnf    -ubackup -p123456    -S  /tmp/mysql3306.sock    --backup  --compress --compress-threads=8   --parallel=4 --stream=xbstream  --target-dir=./ |ssh 10.0.8.11  "cat - >/tools/backup/db3306_`date +%Y%m%d`.xbstream"

备份完后解压:
xbstream -x <  backup.xbstream


如果出现位置点不一样
- 备份之前flush logs
- 事务引擎和非事务引擎混合
- 备份之前reset master
xtrabackup    --defaults-file=/data/mysql/mysql3306/my.cnf    -ubackup -p123456    -S  /tmp/mysql3306.sock --encrypt=AES256  --encrypt=AES256 --encrypt-key=$KEY   --backup  --stream=tar ./|ssh 10.0.8.11 "gzip - >/tools/backup/db3306_`data +%Y%m%d.gz`"


### mysql8.0新特性clone plugin
[参考资料](https://dev.mysql.com/doc/refman/8.0/en/clone-plugin-installation.html)  

```
添加如下参数
[mysqld]
plugin-load-add=mysql_clone.so
sql_require_primary_key=on;
explicit_defaults_for_timestamp=on;
mysqlx_port=33060;

1. 本地克隆
create user clone_user@'%' identified by '123456';
grant backup_admin on *.*  to clone_user@'%' ;
clone local data directory='/data/mysql/mysql3307/data'; 注意:data目录不能存在,上级目录需要mysql用户权限
克隆完后使用mysqld_safe  --defaults-file=/data/mysql/mysql3307/my.cnf  &启动实例即可,官方推荐使用mysqld_safe启动

远程克隆:

1.确保捐赠者和接受者都安装了克隆插件
2. 捐赠者授权10.0.8.11
create user clone_user@'%' identified by '123456';
grant backup_admin on *.*  to clone_user@'%' ;
3. 接受者授权10.0.8.12
create user clone_user@'%' identified by '123456';
grant CLONE_ADMIN on *.*  to clone_user@'%';
4.接受者设置捐赠者列表清单
mysql -uclone_user -h10.0.0.8.12 
SET GLOBAL clone_valid_donor_list = '10.0.8.11:3306';
5. 接受者开始拉取克隆捐赠者数据
clone INSTANCE FROM clone_user@'10.0.8.11':3306  IDENTIFIED BY '123456';

注意:使用clone_plugin安装官方说明都使用mysqld_safe  --defaults-file=/data/mysql/mysql3307/my.cnf  &启动,远程克隆后等待服务自动重启即可
原来的data目录,自动备份被daba.bak
```

### 表空间传输

```
限制条件:
1. 不能有主外键
2. 

flush table tabname for export;
cp tabname.ibd  tabname.cfg 
unlock tables;


alter table tabname discard tablespace; 千万不要在主库上面执行,慎用
cp tabname.ibd  tabname.cfg ;注意mysql权限       
alter table tabname import tablespace;


```

### mydumper和myload
```sh
# 全库备份，mydumper由于不能指定备份多个库，需要使用正则表达式
./mydumper  -h 127.0.0.1  -u root  -p 123456 -P 3306 -x '^(?!(mysql|information_schema|performance_schema|sys))'   -G -R -E -c  -t 8 -o mysql_backup

# 备份多个库
./mydumper  -h 127.0.0.1  -u root  -p 123456 -P 3306 -x 'db1|db2'  -G -R -E -c  -t 8 -o mysql_backup



-- 导出所有数据库，不包含mysql|information_schema|performance_schema|sys。且对trigger(G)、routines(R)、events(E)也导出，进行数据压缩(c)，且8线程(t)导出

-o不指定文件路径 默认默认export-YYYYMMDD-HHMMSS
-m 只备份数据
-d 只备份表结构
-x --regex正则表达式
-c 压缩备份





-- 备份多个库
mydumper -u root -p 123456 -P 3306 -h 192.168.10.11 --regex 'lijiamandb|db1' 

./mydumper  -S /data/mysql/mysql3306/tmp/mysql3306.sock -B dbname   -o /root/mydumper

# 备份表
./mydumper  -S /data/mysql/mysql3306/tmp/mysql3306.sock -B dbname -T t1,t2..    -o /root/mydumper
# 参考连接
https://www.cnblogs.com/lijiaman/p/14799813.html

# myloader导入
 ./myloader  -S /data/mysql/mysql3307/tmp/mysql3307.sock  -o  -e -d export-20230524-155655/
-o：在恢复时，如果表存在，则先删除
-e：相当于这个参数sql_log_bin 
-d：备份目录

```

### postgres备份工具
```sh
PostgreSQL 协议连接方式：
PGPASSWORD=abc psql -h 127.0.0.1 -U abc -p 47001 -d postgres
psql postgres://abc:abc@127.0.0.1:47001/postgres

# 备份某个库
PGPASSWORD=abc pg_dump -h127.0.0.1 -p47001  -U abc -d postgres> postgres.sql

PGPASSWORD=abc pg_dump -h127.0.0.1 -p47001  -U abc -d postgres --no-shard-option > postgres.sql
# 只备份表结构
PGPASSWORD=abc pg_dump -h127.0.0.1 -p47001  -U abc -d postgres -s> postgres.sql

PGPASSWORD=abc pg_dump -h127.0.0.1 -p47001  -U abc -d postgres --no-shard-option -s> postgres.sql
# 只备份数据
PGPASSWORD=abc pg_dump -h127.0.0.1 -p47001  -U abc postgres -a> postgres.sql

PGPASSWORD=abc pg_dump -h127.0.0.1 -p47001  -U abc -d postgres --no-shard-option -a> postgres.sql

-d: 指定数据库
-s：只导出表结构
-a：只导出数据
-t：指定某个表
-n：指定模式


-Fc:二进制格式备份文件(尺寸最小)
PGPASSWORD=abc pg_dump  -Fc    --no-shard-option  -h127.0.0.1    -p47001  -U abc -d arch_basex -f  arch_basex.dump
-- 导入数据的时候需要创建新库或者指定其它库导入(适合备份从test库到test2库中)
PGPASSWORD=abc pg_restore      -h127.0.0.1   -p47001  -U abc -d      test   arch_basex.dump

-Ft:tar格式备份文件
PGPASSWORD=abc pg_dump  -Ft    --no-shard-option  -h127.0.0.1    -p47001  -U abc -d arch_basex -f  arch_basex.tar
-- 导入数据的时候需要创建新库或者指定其它库导入(适合备份从test库到test2库中)
PGPASSWORD=abc pg_restore      -h127.0.0.1   -p47001  -U abc -d     test     arch_basex.tar

-Fd:以目录的格式创建备份
-j:参数指定同时几个进程来同时执行，每个进程同时只处理一个表的数据。
PGPASSWORD=abc pg_dump  -Fd -j4  --no-shard-option  -h127.0.0.1   -p47001  -U abc -d arch_basex -f  arch_basex.dir
-- 导入数据的时候需要创建新库或者指定其它库导入(适合备份从test库到test2库中)
PGPASSWORD=abc pg_restore -j4  -h127.0.0.1   -p47001  -U abc -d test  arch_basex.dir





# 数据库之间导入
1. 在同一个库之间数据迁移
PGPASSWORD=abc pg_dump --no-shard-option -h192.168.0.176 -p47001  -U abc -d  arch_basex| psql postgres://abc:abc@192.168.0.176:47001/test


2、在数据库之间进行某个数据库迁移
pg dump -h pg1 -p 1922 -U postgres testdb|psql -h pg2 -p 5432 -U postgres testdb
3、迁移所有的数据库到目标数据库
pg_dumpall -h pg1 -p 1922 -U postgres |psql -h pg2 -p 5432 -U postgres
```